<h2>You're out of order! The whole trial is out of order!</h2>
<p>Sorting data is extremely important. <i>How</i> we sort that data is equally important. In this lesson, we will be
  covering the use of the <b>matSort</b> directive in a <b>matTable</b> component to add custom, chained sorting to our
  data. In the example below, we have 25 colors generated by a subset of hues, saturations, and luminosities. In the
  example below, our table will sort from left to right, ascending or descending, based on the <i>matSort</i> directive
  attached to the table header. In layman's terms, we'll start at column 1. If it has a sort applied, we'll apply it.
  Then we move to column 2, column 3, etc. to rinse and repeat.</p>
<app-example1></app-example1>
<p>And here's the code:</p>
<app-code-snippet [lessonType]="'material'" [ts]="true" [scss]="true" [html]="true" [lesson]="1" [example]="1"
  [fileType]="'component'"></app-code-snippet>
<p>So let's break down how this works. In the HTML, we have looped through our array of <i>displayedColumns</i> and
  generally followed the documentation for a <a
    href="https://material.angular.io/components/table/overview" target="_blank">matTable</a> component. The primary difference between
  our table and Material's is that our matSort directive is applied directly to our mat-header-cell, where Material
  assigns it to the table.</p>
<p>Material Documentation:</p>
<pre><code class="lang-html" [innerHTML]="materialTableCode"></code></pre>
<p>Ornstio:</p>
<pre><code class="lang-html" [innerHTML]="ornstioTableCode"></code></pre>
<p> You see, a mat-header-cell doesn't know what to do with a matSort, but it does supply our
  directional arrows, so now we have to tell it what to do. By adding a (click) that triggers an observable emission, we
  can handle all of our custom sorting inside of our subscription. In the TS above, I have added logic to handle the
  sorting of strings, numbers, booleans, and Dates. You can customize this function to fit whatever data type you need.
  We then use a fantastic little library called <a href="https://www.npmjs.com/package/thenby" target="_blank">thenBy.js</a> to handle
  our chained sorting. Out of the box, ES6 does not support chained sorting. It will sort by your first criteria, then
  it will resort by the second criteria, and so on. So instead of reinventing the wheel and creating a massive sorting
  function, we will leverage some existing technology that works great.
</p>

<p>By referencing our largely useless <i>matSort</i> directives using <i>ViewChildren</i>, we can access the code to
  figure out what direction that <i>matSort</i> is following, as well as the column that it applies to. Looping through
  our array of <i>ViewChildren</i>, we check to see if an ascending or descending direction has been applied to that
  column. If it has, we build our <i>thenBy</i> sorting statement using our custom sorting functions (in this example
  all are handled by the <i>sortBy</i> function I wrote).
  Now, that useless matSort is actually driving the sorting of the table via the observable subscription, which
  ultimately replaces the data in the table with the newly chain-sorted data.</p>
<app-lesson-footer [lessonType]="'material'" [lesson]="1"></app-lesson-footer>